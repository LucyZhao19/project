In my final project, I used flask to execute the webpage from app.py. 
After the user selects the appropriate inputs and submits the input (by clicking the submit button), the user input is submitted via “POST” and goes through app.py. In app.py, the script first deletes any previous snakemake outputs (which are stored in the “./static” folder). Then, the script saves the user-selected fastq filename and human reference chromosome name into a csv file called “user_input.csv”, where the “sample” column lists the fastq sample name and the “reference” column lists the corresponding chromosome name. Subsequently, app.py uses executes the snakemake command (snakemake --forceall --cores 3) through the command-line interface. 

The snakemake command executes Snakefile, which stores the sample and chromosome reference of the “user_input.csv” into the list “SAMPLE” and “REFERENCE”. The expand() function refers the {sample} and {reference} variable to the sample(s) stored in SAMPLE and the reference(s) stored in REFERENCE. For a given rule, the indented lines under “input:” refer to the location of input files, the indented lines under “output:” specify the location and filename of the desired output, and the indented lines under “shell:” specify the comment that is executed via the command-line interface. As variant calling requires multiple steps, the rules are listed in sequential order, where the output of the previous rule (e.g. “mapped_reads/{sample}.bam” of rule bwa_map) serves as the input to the subsequent rule (e.g. rule samtools_sort). 
The variant calling pipeline is executed in the following sequential manner:
-	In rule align_and_sort_reads, bwa mem aligns reads of the selected sample (e.g. A.fastq file) to the specified human reference chromosome (e.g. chr9.fa) and generates a SAM file (https://bio-bwa.sourceforge.net/). Subsequently samtools sort re-orders reads of the SAM output by the position and chromosome number (e.g. reads located at the first base-pair of chromosome 1 will be the first read in the sorted BAM file) and outputs a sorted BAM file in the “sorted_reads” folder (https://www.htslib.org/doc/samtools-sort.html). 
-	In rule index_bam, samtools index generates a BAM.BAI file, which allows efficient identification of all reads that are mapped to a particular chromosomal region (https://www.htslib.org/doc/samtools-index.html). 
-	In rule call_mutation, bcftools mpileup uses the specified reference chromosome and BAM and BAM.BAI files (that are generated from previous rules) to identify the most likely nucleotide that the sample has at each position in the reference chromosome. Then, bcftools call identifies the variants (i.e. nucleotide in the sample that differs from the expected nucleotide in the reference chromosome) and saves the variant and corresponding position information in a .txt file (https://www.chg.ox.ac.uk/~gav/projects/oxford_statgen_summer_school/website/next_generation_sequencing/variant_calling_and_imputation/Variant_calling/). 
-	Upon successful completion of the variant calling pipeline, snakefile generates a report.html, which contains the variant calling workflow and the code for each rule. 
After the snakemake command finishes running, snakemake’s output .txt file (which contains a list of variants) is displayed in result.html, and the user can freely download the .txt file from the website. 
